import os
from datetime import datetime as dt

import cv2
import numpy as np
import pandas as pd
from easyocr import Reader

reader = Reader(['en'])

def main():
    folder_path = r'C:\Users\josephine.williams\python_env\lcd_ocr\screens'
    csv = 'Monitor Readings.csv'
    
    dataframe = pd.read_csv(csv)
    process_from_folder(folder_path, dataframe, csv)

def process_from_folder(folder, df, csv):
    """
    Processes images from a folder and sends OCR results to a CSV file.
    
    Args:
        folder (str): Folder path containing the images of the monitor.
        df (pd.DataFrame): DataFrame to append the new readings.
        csv (str): Path to the CSV file which stores OCR results from the DataFrame.
    """
    for file in os.listdir(folder):
        if file.endswith(".png"):
            img = cv2.imread(os.path.join(folder, file))
            processed_img = process_image(img)
            if processed_img is not None:
                ocr_result = reader.readtext(processed_img)
                send_results(ocr_result, df, csv, file)

def process_image(image):
    """
    Process the image to extract readable text from a digital screen.
    
    Args:
        image (np.ndarray): Array from the input image.
    
    Returns:
        np.ndarray: Processed image ready for OCR.
    """
    # Uncomment line below if the image needs to be rotated by 'angle' degrees. 
    # image = imutils.rotate(image, angle=10)

    # Resize the image and convert to HSV
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    
    # Insert HSV min/max values, calibrated from hsv_selector.py
    hmin, smin, vmin = 35, 200, 30
    hmax, smax, vmax = 90, 255, 255
    
    # Find high/low values for HSV masking
    lower = np.array([hmin, smin, vmin], np.uint8)
    upper = np.array([hmax, smax, vmax], np.uint8)
    
    # Apply thresholding
    thresh = cv2.inRange(hsv, lower, upper)

    # Change brightness/contrast values here:
    brightness = 255
    contrast = 127

    # Find contours and extract the largest contour (which is our display monitor)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(largest_contour)
        cropped = image[y:y+h, x:x+w]
        
        filtered = cv2.addWeighted(cropped, 1 + contrast / 127.0, cropped, 0, brightness - 255)
        filtered = resize_to_width(filtered, 200)
        # cv2.imwrite('cropped.jpg', filtered)
        # cv2.waitKey(0)
        return filtered
    return None

def take_numbers(text):
    """
    Extracts the number from the text generated by EasyOCR, excluding units (SM3 or SM3/H).
    
    Args:
        text (str): Text generated by EasyOCR's reading.
    
    Returns:
        str: Extracted number from the text.
    """
    pos = -1
    for i, char in enumerate(text):
        if char in [' ', 'S', 'M', 'H']:
            pos = i
            break
    return text[:pos] if pos != -1 else text

def send_results(easy_ocr_result, df, csv, file=None):
    """
    Sends the results of the monitor reading to a CSV file.
    
    Args:
        easy_ocr_result (list): OCR result from EasyOCR.
        df (pd.DataFrame): DataFrame to append the new readings.
        csv (str): Path to the CSV file which stores OCR results from the DataFrame.
    """
    nums = [0, 0]
    index = 0
    for _, text, _ in easy_ocr_result:
        temp = take_numbers(text)
        if temp:
            nums[index] = temp
            index += 1
            if index >= 2:
                break
    
    try:
        sm3h, sm3 = float(nums[0]), int(nums[1])
    except ValueError:
        return
    
    current = dt.now()
    date = current.strftime("%Y-%m-%d")
    time = current.strftime("%H:%M:%S")
    
    new_data = [date, time, sm3h, sm3]
    df.loc[len(df)] = new_data
    
    df.to_csv(csv, mode='w', header=True, index=False)
    print(new_data, file)

def resize_to_width(img, width):
    """
    Resizes the input image to the specified width while maintaining the aspect ratio.
    
    Args:
        img (np.ndarray): Input image.
        width (int): Desired width of the resized image.
    
    Returns:
        np.ndarray: Resized image with the specified width.
    """
    height = int(img.shape[0] * width / img.shape[1])
    return cv2.resize(img, (width, height))

def resize_to_scale(img, scale):
    """
    Resizes the input image by a specified scale percentage.
    
    Args:
        img (np.ndarray): Input image.
        scale (float): Scale percentage to resize the image.
    
    Returns:
        np.ndarray: Resized image scaled by the specified percentage.
    """
    width = int(img.shape[1] * scale / 100)
    height = int(img.shape[0] * scale / 100)
    return cv2.resize(img, (width, height), interpolation=cv2.INTER_AREA)
    
if __name__ == "__main__":
    main()